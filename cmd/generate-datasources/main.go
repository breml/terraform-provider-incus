package main

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"go/format"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/Masterminds/sprig/v3"
	"github.com/lmittmann/tint"
	"github.com/spf13/pflag"
)

//go:embed tmpl
var templateFS embed.FS

const generatedByPreamble = `// Code generated by generate-datasources; DO NOT EDIT.

`

// FileType represents a specific type of file.
type FileType string

const (
	FileTypeGo       FileType = "go"
	FileTypeMarkdown FileType = "markdown"
)

// targets is a list of files, which are generated for each resource seperatly.
var targets = []struct {
	// Name of the template file in the `tmpl` subfolder.
	TemplateName string

	// destination path and file name. Is processed with Go template and has
	// access to the complete set of arguments of the entity. See entityArgs below.
	TargetName string

	// Type of the target file, e.g. `go`. Mainly used to control the post
	// processing, e.g. for `go` files automated formatting is applied.
	TargetFileType FileType
}{
	{
		TemplateName:   "datasource.go.gotmpl",
		TargetName:     "internal/{{ .PackageName }}/datasource_{{ .Name }}_gen.go",
		TargetFileType: FileTypeGo,
	},
	{
		TemplateName:   "docs.md.gotmpl",
		TargetName:     "docs/data-sources/{{ .Name }}.md",
		TargetFileType: FileTypeMarkdown,
	},
}

// globalTarges is a list of files, which are only generated once and not
// for each resource seperatly, thous global.
// This is generally used for cases, where all the generated are mentioned
// in some sort of an index.
var globalTargets = []struct {
	// Name of the template file in the `tmpl/global` subfolder.
	TemplateName string

	// destination path and file name. Is processed with Go template and has
	// access to the complete set of arguments of the entity. See entityArgs below.
	TargetName string
}{
	{
		TemplateName: "provider.go.gotmpl",
		TargetName:   "internal/provider/provider_gen.go",
	},
}

// entityArgs is the argument, which is passed when the Go template is executed.
// It differs somewhat from the settings available in `generate-datasources.yml`,
// since it contains pre-computed attributes.
type entityArgs struct {
	// Value from `name`.
	Name string

	// Value from `description`.
	Description string

	// Value from `notes`.
	Notes string

	// Value from `package-name`.
	PackageName string

	// ObjectNamePropertyName is the name giving attribute of the resource, which
	// is either `name` or the value from `object-name-property-name`.
	ObjectNamePropertyName string

	// ObjectNamePropertyDefaultValue is default value used in the documentation
	// for the name defining property. Defaults to `default`.
	ObjectNamePropertyDefaultValue string

	// Value from `incus-get-method`
	IncusGetMethod string

	// `true`, if `partent` is not empty.
	HasParent bool

	// Value from `parent`.
	ParentName string

	// Inverted value from `has-no-project`.
	HasProject bool

	// Inverted value from `has-no-status`.
	HasStatus bool

	// Value from `has-location`.
	HasLocation bool

	// Value from `has-locations`.
	HasLocations bool

	// Value from `extra-id-attribute`.
	ExtraIDAttribute ExtraAttribute

	// Value from `extra-attributes`.
	ExtraAttributes []ExtraAttribute

	// Value from `extra-descriptions`.
	ExtraDescriptions map[string]string
}

func main() {
	ctx := context.Background()

	flagConfigFile := pflag.String("config", "generate-datasources.yaml", "filename of the configfile")
	flagLogDebug := pflag.BoolP("debug", "d", false, "Show all debug messages")
	flagLogVerbose := pflag.BoolP("verbose", "v", false, "Show all information messages")

	flagOnlyTemplate := pflag.String("only-template", "", "Limit code generation to this template")
	flagOnlyEntity := pflag.String("only-entity", "", "Limit code generation to this entity")

	pflag.Parse()

	initLogger(*flagLogVerbose, *flagLogDebug)
	slog.DebugContext(ctx, "config file", slog.String("filename", *flagConfigFile))

	var cfg Config
	err := cfg.LoadConfig(*flagConfigFile)
	must(err)

	allEntities := make(map[string]entityArgs, len(cfg))

	for name, entity := range mapOrderedByKey(cfg) {
		if entity.ObjectNamePropertyName == "" {
			cfg[name].ObjectNamePropertyName = "name"
		}

		if entity.ObjectNamePropertyDefaultValue == "" {
			cfg[name].ObjectNamePropertyDefaultValue = "default"
		}

		slog.DebugContext(ctx, "entity config", slog.String("name", name), slog.Any("config", entity))
	}

	funcsMap := sprig.FuncMap()
	funcsMap["pascalcase"] = PascalCase
	funcsMap["camelcase"] = CamelCase
	funcsMap["kebabcase"] = KebabCase
	funcsMap["titlecase"] = TitleCase
	funcsMap["words"] = Words

	t := template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/*.gotmpl")
	must(err)

	for name, entity := range mapOrderedByKey(cfg) {
		args := entityArgs{
			Name:                           name,
			Description:                    entity.Description,
			Notes:                          entity.Notes,
			PackageName:                    entity.PackageName,
			ObjectNamePropertyName:         entity.ObjectNamePropertyName,
			ObjectNamePropertyDefaultValue: entity.ObjectNamePropertyDefaultValue,
			IncusGetMethod:                 entity.IncusGetMethod,
			HasParent:                      entity.ParentName != "",
			ParentName:                     entity.ParentName,
			HasProject:                     !entity.HasNoProject,
			HasStatus:                      !entity.HasNoStatus,
			HasLocation:                    entity.HasLocation,
			HasLocations:                   entity.HasLocations,
			ExtraIDAttribute:               entity.ExtraIDAttribute,
			ExtraAttributes:                entity.ExtraAttributes,
			ExtraDescriptions:              entity.ExtraDescriptions,
		}

		allEntities[name] = args

		if *flagOnlyEntity != "" && *flagOnlyEntity != name {
			continue
		}

		for _, target := range targets {
			if *flagOnlyTemplate != "" && *flagOnlyTemplate != target.TemplateName {
				continue
			}

			slog.InfoContext(ctx, "generating", slog.String("name", args.Name), slog.String("template", target.TemplateName))

			filename := strings.Builder{}

			filenameTmpl, err := template.New("name").Funcs(funcsMap).Parse(target.TargetName)
			must(err)

			err = filenameTmpl.Execute(&filename, args)
			must(err)

			targetDir := filepath.Dir(filename.String())
			if !directoryExists(targetDir) {
				err = os.MkdirAll(targetDir, 0o700)
				must(err)
			}

			buf := bytes.Buffer{}

			if target.TargetFileType != FileTypeMarkdown {
				_, err = buf.WriteString(generatedByPreamble)
				must(err)
			}

			err = t.ExecuteTemplate(&buf, target.TemplateName, args)
			must(err)

			formattedSource := buf.Bytes()
			if target.TargetFileType == FileTypeGo {
				formattedSource, err = format.Source(buf.Bytes())
				if err != nil {
					formattedSource = buf.Bytes()
					slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", filename.String()))
				}
			}

			err = os.WriteFile(filename.String(), formattedSource, 0o600)
			must(err)
		}
	}

	t = template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/global/*.gotmpl")
	must(err)

	for _, target := range globalTargets {
		if *flagOnlyTemplate != "" && *flagOnlyTemplate != target.TemplateName {
			continue
		}

		slog.InfoContext(ctx, "generating global", slog.String("template", target.TemplateName))

		targetDir := filepath.Dir(target.TargetName)
		if !directoryExists(targetDir) {
			err = os.MkdirAll(targetDir, 0o700)
			must(err)
		}

		buf := bytes.Buffer{}

		_, err = buf.WriteString(generatedByPreamble)
		must(err)

		err = t.ExecuteTemplate(&buf, target.TemplateName, allEntities)
		must(err)

		formattedSource, err := format.Source(buf.Bytes())
		if err != nil {
			formattedSource = buf.Bytes()
			slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", target.TargetName))
		}

		err = os.WriteFile(target.TargetName, formattedSource, 0o600)
		must(err)
	}
}

// must is a convenience function to end the processing with a panic in the case of an error.
func must(err error) {
	if err != nil {
		slog.ErrorContext(context.Background(), "generate-datasources failed", slog.Any("err", err))
		panic("die")
	}
}

// directoryExists returns true, if the given path does exist and is of type
// directory. Symlinks are resolved, sucht that the effective target is checked.
// Otherwise false is returned.
func directoryExists(name string) bool {
	info, err := os.Stat(name)
	if err != nil && errors.Is(err, fs.ErrNotExist) {
		return false
	}

	return info.IsDir()
}

func initLogger(verbose bool, debug bool) {
	level := slog.LevelWarn

	if verbose {
		level = slog.LevelInfo
	}

	if debug {
		level = slog.LevelDebug
	}

	slog.SetDefault(
		slog.New(
			tint.NewHandler(
				os.Stderr,
				&tint.Options{
					Level:      level,
					TimeFormat: time.RFC3339,
					AddSource:  debug,
				},
			),
		),
	)
}
